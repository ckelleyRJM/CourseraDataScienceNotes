{\rtf1\ansi\ansicpg1252\cocoartf1504
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;\csgray\c100000;}
\margl1440\margr1440\vieww33400\viewh18600\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Count number of flags with orange in them. Dataset \'91flags\'92 has a column binary \'91orange\'92.\
\
* R: sum(flags$orange)\
* SQL: select count(*) from flags where orange = 1\
\
Find total number of flags with each color.\
\
* R: \
** flag_colors <- flags[, 11:17] ## build data.frame with just the color columns from `flags`\
** sapply(flag_colors, sum) ## run sapply() on the segmented data set\
* SQL: This is pretty difficult. Have to write subqueries for each column.\
\
\
\
partition over / group by in SQL is\'85. in R\
\
\
tapply splits a table based on values of a column in that table. For example,\
\
> tapply(flags$population, flags$landmass, summary)\
\
gives summary data about populations among each landmass group. The landmass groups are defined based on the dataset, `flags`.\
\
\
\
tapply is, essentially, sapply with a split embedded. For example, these two are the same:\
* tapply(mtcars$mpg, mtcars$cyl, mean)\
* sapply(split(mtcars$mpg, mtcars$cyl), mean)}